---
title: "Recruitment update"
author: "Carlos Chaccour, Joe Brew"
date: "`r paste0(format(Sys.time(), '%d %B, %Y at %H:%M:%S'), '. Time zone: ', Sys.timezone())`"
fig_height: 2.6
fig_width: 4
output:
  html_document:
    pandoc_args: [
      "+RTS", "-K16000m",
      "-RTS"
    ]
    toc: true
    toc_float: true
    theme: sandstone
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = TRUE, # Render report, even with errors
               cache = F)

library(tidyverse)
library(cism)
library(data.table)
library(ggplot2)
library(automap)
library(akima)
library(RColorBrewer)

clean_perm_id <- function(perm_id){
  x <- strsplit(perm_id, '-')
  y <- lapply(x, 
         function(x){
           as.numeric(as.character(x))
         })
  z <- lapply(y, function(a){
    paste0(a, collapse = '-')
  })
  zz <- unlist(z)
  return(zz)
}
```


```{r}
# Source the file read-in
source('recruitment_update.R')

# Recode hf_id
hf_id_df <- 
  data_frame(hf_id = 1:12,
             hf = c(letters[1:12]))
pcd <- pcd %>%
  mutate(hf_id = as.numeric(hf_id)) %>%
  left_join(hf_id_df)

# Clean up data
pcd <- pcd %>%
  mutate(tdr = ifelse(tdr == 1, 'Got RDT',
                      ifelse(tdr == 2, 'No RDT', NA)),
         tdr_res = ifelse(tdr_res == 1, 'Positive',
                          ifelse(tdr_res == 2, 'Negative', NA)))

# Filter only under 5s for pcd
pcd <- pcd %>%
  filter(age == 1)

# Define simple function for plotting
simple_plot <- function(var, data = NULL){
  if(is.null(data)){
    data <- pcd
  }
  x <- data %>%
  group_by_(var) %>%
  tally %>%
  mutate(p = n / sum(n) * 100) %>%
    rename_(x = var)
return(ggplot(data = x,
       aes(x = x,
           y = n)) +
  geom_bar(stat = 'identity',
           fill = 'darkorange',
           alpha = 0.6) +
    geom_label(aes(label = paste0(round(p, digits = 2), '%'))) +
  theme_cism())
}

# Get village centroids
village_centroids <- master_table %>%
  group_by(village = village_number) %>%
  summarise(lng = mean(lng, na.rm = TRUE),
            lat = mean(lat, na.rm = TRUE),
            n = n())

# Get map of mop
library(cism)
moz2 <- moz2
zam <- moz2_fortified %>%
  filter(id == 'Mopeia')
zam_sp <- moz2[moz2@data$NAME_2 == 'Mopeia',]

moz2 <- raster::getData('GADM', country = 'MOZ', level = 2)
# Make visit_date a date object
pcd$visit_date <- as.Date(pcd$visit_date)
```

```{r}
# Get participants for the cross

# Read in some saved objects from the December doc
# Save clusters and census for january revisions
load('selected_clusters.RData')
load('children.RData')
load('census.RData')

# So, we can sample children at individual level, but for adults, 
# we'll need to just select a house

if('cross_sectional2.RData' %in% dir('backups')){
  load('backups/cross_sectional2.RData') 
  load('backups/cross_sectional_target_numbers2.RData')
  } else {
    
  set.seed(123)
  # Get households by cluster
  selected <- 
    census %>%
                dplyr::select(uri, 
                              house_number,
                              health_facility,
                              cluster,
                              lng,
                              lat,
                              within_1k_voronoi_buffer,
                              village,
                  cluster,
                  head_name,
                  local_village_name,
                  number_of_children,
                  number_of_residents,
                  administrative_post) %>%
    mutate(number_of_adults = number_of_residents - number_of_children) %>%
    # Bring in the cluster info to children
    left_join(clusters %>%
                dplyr::select(cluster,
                              size,
                              spray_status),
              by = 'cluster') %>%
    # Filter out those whose spray status is not known
    filter(!is.na(spray_status)) %>%
    # Filter out those who are not in the core area
    filter(!within_1k_voronoi_buffer) 
  # Randomly re-shuffle order
  selected <- selected[sample(1:nrow(selected), nrow(selected)),]
  
  
  
  # # Get the kids that are in each house
  # right <- children %>%
  #   mutate(in_acd = clean_perm_id(permid) %in%
  #               unique(clean_perm_id(acd$perm_id))) %>%
  #   filter(!in_acd) 
  # right <- right %>%
  #   sample_n(nrow(right)) %>%
  #   mutate(dummy = 1) %>%
  #   group_by(parent_auri) %>%
  #   summarise(children = paste0(cumsum(dummy), ' ', name, collapse = ', '))
  # 
  # selected <- 
  #   selected %>%
  #   left_join(right,
  #             by = c('uri' = 'parent_auri')) %>%
  #   mutate(children = if_else(is.na(children), 
  #                             'No children',
  #                             children))
  
  # Order by cluster
  selected <- selected %>%
    arrange(cluster)
  
  # remove extra variables
  selected <- 
    selected %>%
    dplyr::select(-within_1k_voronoi_buffer,
                  -village)
  
  # Perform a random selection, stratifying by cluster size
  vals <- rep(c(128, 128, 129), 2)
  counter <- 0
  # Get a random_selection
  results <- list()
  sss <- c('No spray', 'Spray')
  szs <- c('Small', 'Medium', 'Large')
  for(ss in 1:length(sss)){
    for(sz in 1:length(szs)){
      counter <- counter + 1
      message(counter)
      message(paste0('ss = ', ss))
      message(paste0('sz = ', sz))
      val <- vals[counter]
      # Get a selection
      sub_data <- 
        selected %>%
        filter(spray_status == sss[ss],
               size == szs[sz])
      this_selection <- sub_data[sample(1:nrow(sub_data), val),]
      results[[counter]] <- this_selection
    }
  }
  pseudo_selected <- bind_rows(results)
  
    # Now that we've gotten a random selection, let's 
  # produce "target numbers" by house
  target_numbers <- 
    selected %>%
    group_by(cluster) %>%
    summarise(n_houses_in_cluster = length(unique(uri)),
              size = first(size),
              villages = paste0(unique(local_village_name), collapse = ', '),
              health_facilities = paste0(unique(health_facility), collapse = ', '),
              administrative_posts = paste0(unique(administrative_post), collapse = ', ')) %>%
    left_join(
      pseudo_selected %>%
        group_by(cluster) %>%
        summarise(target_number = length(unique(uri)))
    )
    target_numbers$target_number  <- 
      ifelse(is.na(target_numbers$target_number), 
              0, 
             target_numbers$target_number)
    
    # Get number of fieldworkers needed
    target_numbers$n_fieldworkers <-
      (target_numbers$target_number %/% 5) + 1
    
  
  # Get target for cluster
  selected <-
    selected %>%
    left_join(target_numbers)
  
  # Ensure random order
  selected <- selected %>%
    mutate(x = 1:nrow(selected))
  selected <- selected[sample(1:nrow(selected), nrow(selected)),]
  
  # Arrange by cluster
  selected <- selected %>%
    arrange(cluster)
  
  # Assign a visit order number
  selected <- 
    selected %>%
    dplyr::select(-x) %>%
    group_by(cluster) %>%
    mutate(visit_number = 1:n()) %>%
    ungroup
  
  # Save
  save(selected, file = 'backups/cross_sectional2.RData')
  write_csv(selected, 'backups/cross_sectional2.csv')
  save(target_numbers, file = 'backups/cross_sectional_target_numbers2.RData')
  write_csv(target_numbers, 'backups/cross_sectional_target_numbers2.csv')
  }
save(selected, file = paste0('backups/cross_sectional_',
                             Sys.Date(),
                             '.RData'))
save(target_numbers, file = paste0('backups/cross_sectional_target_numbers_',
                             Sys.Date(),
                             '.RData'))
```

# Passive case detection data


## RDT testing rate

The below chart shows the total RDT testing rate, from the passive case detection (PCD) database.

```{r}
simple_plot(var = 'tdr') +
  labs(x = 'Test status',
       y = 'People',
       title = 'RDT testing') 
```

The below table shows the above chart's raw numbers.

```{r}
table(pcd$tdr)
```

## RDT testing rate over time

The below chart shows the number of patients tested and not tested in the PCD database over time. 

```{r}
x <- pcd %>%
  group_by(date = visit_date) %>%
  summarise(tested = length(which(tdr == 'Got RDT')),
            not_tested = length(which(tdr == 'No RDT')))
y <- x
x <- gather(x, key, value, tested:not_tested)

ggplot(data = x %>%
         filter(date >= '2016-12-01') %>%
         mutate(key = gsub("_", ' ', key)),
       aes(x = date,
           y = value,
           color = key)) +
  geom_line() +
  theme_cism() +
  labs(title = 'Tests over time: daily',
       subtitle = 'PCD database',
       x = 'Date',
       y = 'People') +
  scale_color_manual(name = '',
                     values = c('darkorange', 'darkgreen'))
```

The below table shows the above chart's raw numbers.

```{r}
DT::datatable(y)
```

The below chart is identical to the above, but shows _cumulative_ PCD patients tested and not tested.

```{r}
x <- x %>%
  arrange(date) %>%
  group_by(key) %>%
  mutate(cum_value = cumsum(value)) %>%
  ungroup 
ggplot(data = x %>%
         filter(date >= '2016-12-01') %>%
         mutate(key = gsub("_", ' ', key)),
       aes(x = date,
           y = cum_value,
           color = key)) +
  geom_line() +
  theme_cism() +
  labs(title = 'Tests over time: cumulative',
       subtitle = 'PCD database',
       x = 'Date',
       y = 'People') +
  scale_color_manual(name = '',
                     values = c('darkorange', 'darkgreen'))
```

## RDT positivity rate

The below chart shows the overall RDT positivty rate from the PCD database.

```{r}
simple_plot(var = 'tdr_res',
            data = pcd %>% filter(!is.na(tdr_res))) +
  labs(x = 'Test outcome',
       y = 'People',
       title = 'RDT outcomes') 
```

The below table shows the same data as above,in raw numbers.

```{r}
table(pcd$tdr_res)
```

### RDT positivity rate over time

The below chart shows the number of test outcomes over time, aggregated at the weekly level.

```{r}
x <- pcd %>%
  mutate(year_week = format(visit_date, '%Y %U')) %>%
  group_by(year_week) %>%
  mutate(week = min(visit_date)) %>%
  group_by(date = week, tdr_res) %>%
  tally

ggplot(data = x %>%
         filter(date >= '2016-12-01'),
       aes(x = date,
           y = n,
           color = tdr_res)) +
  geom_line() +
  theme_cism() +
  labs(x = 'Date',
       y = 'People',
       title = 'Raw number of test outcomes',
       subtitle = 'Aggregated to weekly level') +
  scale_color_manual(name = '',
                     values = c('darkorange', 'darkgreen'))
```

## Overall positivity rate

```{r}
y <- 
  pcd %>%
  filter(!is.na(tdr_res)) %>%
  mutate(year_week = format(visit_date, '%Y %U')) %>%
  group_by(year_week) %>%
  mutate(week = min(visit_date)) %>%
  group_by(date = week) %>%
  summarise(p = length(which(tdr_res == 'Positive')) / n() * 100)

ggplot(data = y %>%
         filter(date >= '2016-12-01'),
       aes(x = date,
           y = p)) +
  geom_area(alpha= 0.6,
            fill = 'darkgreen') +
  theme_cism() +
  labs(title = 'Overall RDT positivity rate',
       x = 'Date',
       y = 'Percentage')
```


## Positivity rate by intervention status over time

The below chart shows the positivity rate over time by patient's spray status (ie, whether the village where they live was assigned to spraying, assigned not to be sprayed, or is unknown/NA).

```{r}
x <- pcd %>%
  mutate(year_week = format(visit_date, '%Y %U')) %>%
  group_by(year_week) %>%
  mutate(week = min(visit_date)) %>%
  group_by(date = week, tdr_res, spray_status) %>%
  tally %>%
  arrange(date) %>%
  group_by(date, spray_status) %>%
  summarise(positives = sum(n[tdr_res == 'Positive'], na.rm = TRUE),
            negatives = sum(n[tdr_res == 'Negative'], na.rm = TRUE),
            n = sum(n, na.rm = TRUE)) %>%
  ungroup %>%
  mutate(positivity_rate = positives / n * 100) %>%
  # Arrange by date and get cumsum
  arrange(date) %>%
  group_by(spray_status) %>%
  mutate(cum_positives = cumsum(positives),
         cum_n = cumsum(n)) %>%
  mutate(cum_positivity_rate = cum_positives / cum_n * 100)


x$days_since_end_of_spray <- x$date - as.Date('2016-10-30')
cols <- colorRampPalette(brewer.pal(n = 8, 'Spectral'))(length(unique(x$spray_status[!is.na(x$spray_status)])))
ggplot(data = x %>% filter(date >= '2016-12-01',
                           !is.na(spray_status)),
       aes(x = days_since_end_of_spray,
           y = positivity_rate,
           group = spray_status,
           fill = spray_status)) +
  geom_bar(stat = 'identity', pos = 'dodge',
           alpha = 0.6) +
  theme_cism() +
  labs(title = 'Week-specific positivity rate',
       subtitle = 'By spray status',
       x = 'Days since end of spraying',
       y = 'Positivity rate') +
  scale_fill_manual(name = '',
                     values = cols,
                     na.value = 'grey') +
  geom_vline(xintercept = 90, lty = 3, alpha = 0.6)
  # geom_vline(xintercept = as.numeric(as.Date('2017-01-15')), lty = 2, alpha = 0.6)
```

The below chart is identical to above, but shows _cumulative_ positivity rate

```{r}
cols <- colorRampPalette(brewer.pal(n = 8, 'Spectral'))(length(unique(x$spray_status[!is.na(x$spray_status)])))

ggplot(data = x %>% filter(date >= '2016-12-01',
                           !is.na(spray_status)),
       aes(x = date,
           y = cum_positivity_rate,
           group = spray_status,
           color = spray_status,
           size = n)) +
  geom_line() +
  theme_cism() +
  labs(title = 'CUMULATIVE positivity rate',
       subtitle = 'By spray status, weekly aggregations',
       x = 'Date',
       y = 'Positivity rate') +
  scale_color_manual(name = '',
                     values = cols,
                     na.value = 'grey')
```

## Cross-table of testing and positivity

The below cross table shows RDT tests by whether an RDT test was administered. A row of only 0's is expected.

```{r}
table(pcd$tdr, pcd$tdr_res)
```

## Cross-table of spray status and positivity

The below cross table shows RDT test results by spray status.

```{r}
table(pcd$spray_status,
      pcd$tdr_res)
```


The below table is identical to above, but instead of showing raw numbers, it shows percentages (by spray status).

```{r}
prop.table(table(pcd$spray_status,
      pcd$tdr_res), 1) * 100
```

## Modeling for odds ratios

What follows is basic code for constructing a binomial logistic regression using the PCD data. This allows us to estimate an odds ratio and 95% confidence interval.

```{r, echo = TRUE}
fit <- glm(tdr_res == 'Positive' ~ spray_status, 
           family = binomial('logit'),
           data = pcd)
ors <- exp(coef(fit))
ci <- exp(confint(fit))

or_df <- data_frame(or = ors[2],
                    lwr = ci[2,1],
                    upr = ci[2,2])

# Round
for (j in 1:ncol(or_df)){
  or_df[,j] <- round(or_df[,j], digits = 2)
}

DT::datatable(or_df)
```

### Interpretation

The likelihood of a positive RDT for those living in sprayed zones is `r or_df$or` that of those living in non-spray zones (95% confidence interval of `r or_df$lwr` to `r or_df$upr`).

## Weekly odds ratios

The below chart shows how our odds ratio (odds of positive RDT, sprayed over non-sprayed) has changed over time (and how confidence intervals have shrunk). An estimate below 1.0 suggests protection from spraying; an estimate above 1.0 suggests that spraying is a risk factor for a postive RDT (this would not be the biologically expected result). Where the vertical 95% confidence bars intersect the dashed line, there is no statistical significance; when they do not interesect, the difference between spray / no-spray groups is considered statistically significant.

```{r}
pcd_week <-
  pcd %>%
  mutate(date = as.Date(visit_date)) %>%
  mutate(year = as.numeric(format(date, '%Y')),
         week = as.numeric(format(date, '%U'))) %>%
  group_by(year, week) %>%
  mutate(date = min(date))

dates <- sort(unique(pcd_week$date))
dates <- dates[dates >= as.Date('2016-12-01')]

results <- list(); results_week <- list()
counter <- 1
for (i in 1:length(dates)){
  the_data <- pcd_week %>%
    filter(date <= dates[i])
  try({
    fit <- glm(tdr_res == 'Positive' ~ spray_status, 
         family = binomial('logit'),
         data = the_data)
    ors <- exp(coef(fit))
    ci_try <- try({
      ci <- exp(confint(fit))
    })
    if(class(ci_try) == "try-error"){
      ci <- data.frame(x = rep(NA, 2),
                       y = rep(NA, 2))
    }
  

  or_df <- data_frame(or = ors[2],
                    lwr = ci[2,1],
                    upr = ci[2,2],
                    date = dates[i])
  results[[counter]] <- or_df
  # counter <- counter + 1
  })
  
  ## Week specific (not cumulative)
    the_data_week <- pcd_week %>%
    filter(date == dates[i])
  try({
    message('Weekly')
    fit_week <- glm(tdr_res == 'Positive' ~ spray_status, 
         family = binomial('logit'),
         data = the_data_week)
    ors_week <- exp(coef(fit_week))
    ci_try_week <- try({
      ci_week <- exp(confint(fit_week))
    })
    if(class(ci_try_week) == "try-error"){
      ci_week <- data.frame(x = rep(NA, 2),
                       y = rep(NA, 2))
    }
  

  or_df_week <- data_frame(or = ors_week[2],
                    lwr = ci_week[2,1],
                    upr = ci_week[2,2],
                    date = dates[i])
  results_week[[counter]] <- or_df_week
  counter <- counter + 1
  })
}
or_df <- bind_rows(results)
or_df_week <- bind_rows(results_week)
```


```{r}
ggplot(data = or_df,
       aes(x = date,
           y = or)) +
  geom_line(alpha = 0.6) +
  geom_linerange(aes(ymin = lwr,
                     ymax = upr),
                 alpha = 0.6) +
  labs(title = 'Odds ratio over time',
       subtitle = 'Cumulative (all estimates included previous observations)',
       x = 'Date',
       y = 'Odds ratio') +
  theme_cism() +
  geom_hline(yintercept = 1, lty = 2) +
  ylim(0, 2)
```


```{r}
ggplot(data = or_df_week,
       aes(x = date,
           y = or)) +
  geom_bar(stat = 'identity', 
           fill = 'darkgreen',
           alpha = 0.6) +
  geom_linerange(aes(ymin = lwr,
                     ymax = upr),
                 alpha = 0.6) +
  labs(title = 'Odds ratio over time',
       subtitle = 'Week-specific (all estimates included previous observations)',
       x = 'Date',
       y = 'Odds ratio') +
  theme_cism() +
  geom_hline(yintercept = 1, lty = 2) +
  ylim(0, 2)
```



## Analysis by health facility

```{r}
x <- 
  pcd %>%
    mutate(date = as.Date(visit_date)) %>%
  mutate(year = as.numeric(format(date, '%Y')),
         week = as.numeric(format(date, '%U'))) %>%
  group_by(year, week) %>%
  mutate(date = min(date)) %>%
  group_by(hf_id, date) %>%
  summarise(malaria = length(which(malaria)),
            visits = n()) %>%
  mutate(p = malaria / visits * 100)

ggplot(dat = x %>%
         filter(date >= '2016-12-01') %>%
         filter(as.numeric(hf_id) <= 12),
       aes(x = date,
           y = p)) +
  # geom_area(fill = 'darkgreen', alpha = 0.5) +
  geom_point(aes(size = visits),
             alpha = 0.5) +
  geom_line(alpha = 0.3) +
  facet_wrap(~hf_id) +
  scale_x_date(date_labels = "%b") +
  labs(title = 'Malaria trends',
       subtitle = 'Weekly aggregated malaria visits as % of all visits by health facility',
       x = 'Date',
       y = 'Percentage') +
  theme_cism()
```

## PCD maps

### Map of total positive RDTs

The below map is a visualization of the _raw_ number of RDT positive results, by village.

```{r}
# Get positivity rate by village
pr_by_village <- 
  pcd %>%
  group_by(village) %>%
  summarise(positives = length(which(tdr_res == 'Positive')),
            negatives = length(which(tdr_res == 'Negative')),
            tested = length(which(!is.na(tdr_res))),
            n_pcd = n()) %>%
  mutate(p_positive = positives / tested * 100)

# Join to centroids
x <- village_centroids %>%
  left_join(pr_by_village)

ggplot(data = zam) +
  geom_polygon(aes(x = long,
           y = lat,
           group = group),
           alpha = 0.6) +
  coord_map() +
  theme_cism() +
  geom_point(data = x,
             aes(x = lng,
                 y = lat,
                 size = positives),
             color = 'darkgreen',
             alpha = 0.8) +
  scale_size_continuous(name = '') +
  xlab('Longitude') +
  ylab('Latitude') +
  labs(title = 'Total positive RDTs by village',
       subtitle = 'Raw numbers')
``` 


### Map of PCD positivity rate

The below chart shows the positivity _rate_ by village.

```{r}
# Map
cism_map(lng = x$lng,
         lat = x$lat,
         x = x$p_positive,
         fspdf = zam) +
  labs(title = 'Positivity rate by village',
       subtitle = 'Percent positive of RDTs administered')
```

### Rasterized / smoothed PCD positivity rate

The below chart shows the "positivity index", a smoothed way of viewing where most positive cases come from. Note: this is not a rate, and is therefore heavily influenced by population.

```{r}
# Create a df with one row for each positive case at village level
map_df <- x
map_df <- map_df[0,]
counter <- 0
for (i in 1:nrow(x)){
 this_df <- x[i,] 
 if(!is.na(this_df$positives)){
    for(j in 1:this_df$positives){
   counter <- counter + 1
   map_df[counter,] <-
     this_df
  } 
 }
}

ggplot() +
  geom_polygon(data = zam, aes(x = long,
           y = lat,
           # z = p_positive,
           group = group),
           alpha = 0.6) +
  coord_map() +
  stat_density2d(data = map_df,
                aes(fill = ..level..,
                  # fill = p_positive,
                    x = lng, 
                    y = lat),
                size = 5, bins = 50, 
                geom = "polygon",
                alpha = 0.5) +
                  theme_cism() +
  labs(title = 'Raw positivity index',
       subtitle = 'Not accounting for population distribution',
       x = 'Longitude',
       y = 'Latitude') +
  scale_fill_gradient2(name = 'Index',
                       low="white",mid="orange",high="red") 
```


The below map shows a smoothed, rasterized surface for positivity rate. Krieging is used to achieve interpolated estimates. Unlike the previous map, here we model a _rate_, which should be independent of population density.

```{r, results = 'hide'}
# Krieging
sp_df <- x
coordinates(sp_df) <- ~lng + lat
proj4string(sp_df) <- proj4string(zam_sp)
sp_df <- sp_df[!is.na(sp_df$p_positive),]
sp_points <- SpatialPoints(sp_df)


# Create a fine grid
pixels_per_side = 200
bottom.left = apply(sp_points@coords,2,min)
top.right = apply(sp_points@coords,2,max)
margin = abs((top.right-bottom.left))/10
bottom.left = bottom.left-margin
top.right = top.right+margin
pixel.size = abs(top.right-bottom.left)/pixels_per_side
g = GridTopology(cellcentre.offset=bottom.left,
             cellsize=pixel.size,
             cells.dim=c(pixels_per_side,pixels_per_side))

# # Clip the grid to the state regions
# map_base_data = subset(map_data("state"), region %in% regions)
# colnames(map_base_data)[match(c("long","lat"),colnames(map_base_data))] = c("longitude","latitude")
# foo = function(x) {
#   state = unique(x$region)
#   print(state)
#   Polygons(list(Polygon(x[,c("latitude","longitude")])),ID=state)
# }
# state_pg = SpatialPolygons(dlply(map_base_data, .(region), foo))
grid_points = SpatialPoints(g)
proj4string(grid_points) <- proj4string(zam_sp)
in_points = !is.na(over(grid_points,polygons(zam_sp)))
fit_points = SpatialPoints(as.data.frame(grid_points)[in_points,])
proj4string(fit_points) <- proj4string(zam_sp)

# make projected before krieging
new_pro <- CRS("+init=epsg:3036")
proj4string(fit_points) <-
  proj4string(zam_sp) <- 
  proj4string(sp_df) <- new_pro

# Do kriging
krig = autoKrige(p_positive~1, sp_df, new_data=fit_points)
interp_data = as.data.frame(krig$krige_output)
colnames(interp_data) = c("longitude","latitude","APPT_pred","APPT_var","APPT_stdev")

# Set up map plot
map_base_aesthetics = aes(x=longitude, y=latitude, group=group)
map_base = geom_polygon(data=zam_sp, map_base_aesthetics)
borders = geom_polygon(data=zam_sp, map_base_aesthetics, color="black", fill=NA)

nbin=20
```

```{r}

ggplot(data=interp_data, aes(x=longitude, y=latitude)) + 
  # geom_polygon(data = zam, aes(x = long,
  #          y = lat,
  #          # z = p_positive,
  #          group = group),
  #          alpha = 0.6) +
  # coord_map() +
  geom_tile(aes(fill=APPT_pred),color=NA) +
  # stat_contour(aes(z=APPT_pred), bins=nbin, color="#999999") +
  scale_fill_gradient2(name = 'Interpolated\npositivity',
                       low="white",mid="orange",high="red", midpoint=mean(interp_data$APPT_pred)) +
  # borders +
  theme_cism() +
  labs(title = 'Interpolated positivity rate',
       subtitle = 'Krieging method',
       x = 'Longitude',
       y = 'Latitude')
  # coord_equal()
  # # geom_point(data=sub_data,color="black",size=0.3)
```



## Incidence calculations

### Overall

```{r}
daily_incidence <-
  pcd %>%
  group_by(date = visit_date) %>%
  summarise(positives = length(which(tdr_res == 'Positive'))) 
daily_incidence$denominator <- nrow(children)

daily_incidence$k <- daily_incidence$positives / daily_incidence$denominator * 1000

ggplot(data = daily_incidence %>%
         filter(date >= '2016-12-01'),
       aes(x = date,
           y = k)) +
  geom_bar(stat = 'identity',
           alpha = 0.6) +
  theme_cism() +
  labs(x = 'Date',
       y = 'Cases per 1,000 population',
       title = 'Incidence through PCD',
       subtitle = 'Positive < 5 cases divided by all < 5')

```

Below is the same data in tabular format

```{r}
DT::datatable(daily_incidence)
```

As an alternative to the above, we can examine weekly incidence.

```{r}
ggplot(data = daily_incidence %>%
         filter(date >= '2016-12-01') %>%
         mutate(year = as.numeric(format(date, '%Y')),
                week = as.numeric(format(date, '%U'))) %>%
         group_by(year, week) %>%
         mutate(date = min(date)) %>%
         ungroup %>%
         group_by(date) %>%
         summarise(k = sum(positives) / mean(denominator) * 1000),
       aes(x = date,
           y = k)) +
  geom_area(alpha = 0.6,
            color = 'black') +
  theme_cism() +
  labs(x = 'Date',
       y = 'Cases per 1,000 population',
       title = 'Weekly incidence through PCD',
       subtitle = 'All positive cases divided by entire population')
```

Alternatively, we can examine the data at the monthly level.

```{r}
ggplot(data = daily_incidence %>%
         filter(date >= '2016-12-01') %>%
         mutate(year = as.numeric(format(date, '%Y')),
                week = as.numeric(format(date, '%U')),
                month = as.numeric(format(date, '%m'))) %>%
         group_by(year, month) %>%
         mutate(date = min(date)) %>%
         ungroup %>%
         group_by(date) %>%
         summarise(k = sum(positives) / mean(denominator) * 1000),
       aes(x = date,
           y = k)) +
  geom_bar(stat = 'identity', 
           alpha = 0.6,
            color = 'black') +
  theme_cism() +
  labs(x = 'Date',
       y = 'Cases per 1,000 population',
       title = 'Montyly incidence through PCD',
       subtitle = 'All positive cases divided by entire population')
```

For true incidence, we can calculate the cumulative number of cases for the period of time divided by the population times time.

```{r, echo = TRUE}
x <- daily_incidence %>%
         filter(date >= '2016-12-01') 
years_at_risk <- length(unique(x$date))/365.25

# Make yearly

overall_incidence <- 
  ((x %>%
  summarise(total = sum(positives)) %>%
  unlist) / 
  # divided by person-months at risk
  (years_at_risk *
  nrow(children))) * 1000
```

The **annual extrapolated incidence** (under 5) is `r x$overall_incidence` infections per 1,000 children-years (not taking into account seasonality).



### By age group

We cannot examine incidence by age, because no birth data exists for children > 5, so age specific incidence cannot be calculated for older age groups. It is also unclear from the census data if the entire adult population was censed or not.

### By spray status

```{r}

village_denom <- children %>%
  group_by(village = village_number) %>%
  tally

village_num <-
  pcd %>%
  group_by(date = visit_date,
           village) %>%
  summarise(positives = length(which(tdr_res == 'Positive')))

#
left <- expand.grid(date = seq(min(village_num$date),
                               max(village_num$date),
                               by = 1),
                    village = village_denom$village)
village_num <- full_join(left, village_num)
village_num$positives[is.na(village_num$positives)] <- 0

x <- 
  left_join(x = village_denom,
            y = village_num) %>%
  # Make weekly
  mutate(year = as.numeric(format(date, '%Y')),
                week = as.numeric(format(date, '%U'))) %>%
         group_by(year, week) %>%
         mutate(date = min(date)) %>%
         ungroup %>%
  group_by(village, date) %>%
  summarise(positives = sum(positives),
            n = mean(n)) %>%
  mutate(k = positives / n * 1000)

# Get spray status
x <- x %>%
  left_join(ss %>%
              rename(village = village_number))

# Group by spray status
x <- x %>%
  group_by(spray_status,
           date) %>%
  summarise(positives = sum(positives),
            n = sum(n)) %>%
  mutate(k = positives / n * 1000)

ggplot(data = x %>%
         filter(date >= '2016-12-01',
                !is.na(spray_status)),
       aes(x = date,
           y = k)) +
  geom_area(alpha = 0.6,
            fill = 'darkblue',
            color = 'black') +
  facet_wrap(~spray_status, nrow = 2) +
  labs(x = 'Date',
       y = 'Cases per 1,000',
       title = 'Weekly incidence by spray status') +
  theme_cism()

ggplot(data = x %>%
         filter(date >= '2016-12-01',
                !is.na(spray_status)),
       aes(x = date,
           y = k,
           fill = spray_status)) +
  # geom_line(alpha = 0.6) +
  geom_bar(stat = 'identity',
           position = 'dodge',
           alpha = 0.6) +
  labs(x = 'Date',
       y = 'Cases per 1,000',
       title = 'Weekly incidence by spray status') +
  theme_cism() +
  scale_fill_manual(name = 'Spray\nstatus',
                     values = c('darkblue', 'darkorange'))

```

The below line chart is the same as the above bar chart.

```{r}
ggplot(data = x %>%
         filter(date >= '2016-12-01',
                !is.na(spray_status)),
       aes(x = date,
           y = k,
           color = spray_status)) +
  geom_line(alpha = 0.6) +
  labs(x = 'Date',
       y = 'Cases per 1,000',
       title = 'Weekly incidence by spray status') +
  theme_cism() +
  scale_color_manual(name = 'Spray\nstatus',
                     values = c('darkblue', 'darkorange'))
```

The below line chart is the same as the above, but it shows _cumulative_ incidence, rather than week-specific.

```{r}
x <- x %>%
  arrange(date) %>%
  group_by(spray_status) %>%
  mutate(k_cum = cumsum(k)) %>%
  ungroup
ggplot(data = x %>%
         filter(date >= '2016-12-01',
                !is.na(spray_status)),
       aes(x = date,
           y = k_cum,
           color = spray_status)) +
  geom_line(alpha = 0.6) +
  labs(x = 'Date',
       y = 'Cases per 1,000',
       title = 'Cumulative incidence by spray status') +
  theme_cism() +
  scale_color_manual(name = 'Spray\nstatus',
                     values = c('darkblue', 'darkorange'))
```

As an alternative to the above, we can also examine the week-specific reduction in incidence associated with spraying:

```{r}
y <- x %>%
   filter(date >= '2016-12-01',
        !is.na(spray_status)) %>%
  dplyr::group_by(date) %>%
  dplyr::summarise(difference = dplyr::first(k[spray_status == 'Spray']) - 
             dplyr::first(k[spray_status == 'No spray']),
             Cases = sum(n)) 

ggplot(data = y,
       aes(x = date,
           y = difference)) +
  geom_point(aes(size = Cases),
             alpha = 0.5) +
  geom_line(alpha = 0.6) +
  theme_cism() +
  geom_hline(yintercept = 0, lty = 2) +
  labs(x = 'Week',
       y = 'Incidence difference per 1,000',
       title = 'Difference in weekly incidence',
       subtitle = 'Per 1,000, spray minus no spray')
```

We can also calculate overall extrapolated annual incidence (as per above), by spray status

```{r}
y <- x %>%
         filter(date >= '2016-12-01') 
# years_at_risk <- as.numeric(diff(range(y$date)))/365.25

# Make yearly
x <-
  y %>%
  group_by(spray_status) %>%
  summarise(cases = sum(positives, na.rm = TRUE),
            population = mean(n, na.rm = TRUE)) %>%
  ungroup %>%
  mutate(yearly_incidence = cases / (years_at_risk * population) * 1000)

```

The **annual extrapolated incidence** (under 5) per 1,000 children-years (not taking into account seasonality). (Population figures need to be adjusted)

```{r}
x
```

# Active case detection data

```{r}
# TO DO: Incorporate all the followup data into ACD.
# Create a chart with x as date and y as person time at risk (line for at risk, red line for infected, no line for lost or not yet tracked) showing 1500 horizontal lines
# add symbols for events (death, lost, etc.)
# Calculate incidence using cases / person time at risk, applying the removal of
# time NOT at risk due to events, censure, etc.

# The ACD data, like the census data, use incorrect permids in those cases of permids containing "-7116-". 

# The "fix" is to replace the house number section of the "permid" column of those permids containing 7116 with the equivalent portion from the "house_number" column.

# However, since the "agregado" is also collected in ACD data, we can apply the same transformation that we apply to the census to get the "corrected" permid.

# Maybe use family id?

acd$kid_number <- unlist(lapply(strsplit(acd$perm_id, '-'), function(x){x[4]}))
children$kid_number <- unlist(lapply(strsplit(children$permid, '-'), function(x){x[4]}))

# Match up family ids
children$family_id <-
  unlist(lapply(strsplit(children$permid, '-'), function(x){paste0(x[1:3], collapse = '-')}))

# Perform the fix
acd$village_correct <- 
  unlist(lapply(strsplit(acd$family_id, '-'), function(x){x[2]}))
acd$perm_id <- 
  paste0(unlist(lapply(strsplit(acd$perm_id, '-'), function(x){x[1]})),
         '-',
         acd$village_correct,
         '-',
  unlist(lapply(strsplit(acd$perm_id, '-'), function(x){paste0(x[3:4], collapse = '-')})))


# THERE ARE STILL MORE CORRECTIONS TO DO HERE
# For now, removing duplicates in ACD.
# After we make the right corrections, there will hopefully be no duplicates in ACD or children
acd <- acd %>%
  filter(!duplicated(perm_id))
children <- children %>%
  filter(!duplicated(permid))

acd$perm_id <- clean_perm_id(acd$perm_id)
children$permid <- clean_perm_id(children$permid)

# Get location into acd using census
acd$house_number <-
  unlist(lapply(strsplit(acd$perm_id, '-'), function(x){paste0(x[1:3], collapse = '-')}))
acd <- acd[!is.na(acd$perm_id),]
acd <- acd %>%
  mutate(house_number = clean_perm_id(house_number)) %>%
  left_join(census %>%
              dplyr::select(house_number,
                            lng,
                            lat) %>%
              mutate(house_number = clean_perm_id(house_number)),
            by = 'house_number')

# # Get location into acd using children dataset
# acd <- acd %>%
#   dplyr::select(-house_number) %>%
#   mutate(perm_id = clean_perm_id(perm_id)) %>%
#   left_join(children %>%
#               mutate(perm_id = clean_perm_id(permid)) %>%
#               dplyr::select(perm_id, status,
#                             parent_auri),
#             by = 'perm_id')
```

```{r}
# To do: when they have malaria, they are no longer at risk for 15 days
# They get visited once monthly
# Overall, we want 
  # - cases: 
  # - denominator: child-time at risk (take out child-time not at risk)
# Make a survival line plot

ggplot(data = acd,
       )
```

## Map of ACD

The below is a map of ACD activity, with each point colored by RDT result.

```{r}
cism_map_interactive(lng = acd$lng,
                     lat = acd$lat,
                     x = ifelse(acd$had_malaria == 1, 
                                'Positive', 
                                'Negative'),
                     popup = paste0('perm-id: ', acd$perm_id),
                     spdf = zam_sp)
```

## Risk maps

There are still problems with matching the `perm_id`s from the ACD dataset with the census. `r length(which(is.na(acd$lng)))` of `nrow(acd)` ACD study observations have no location associated with them.


```{r, results = 'hide'}
# Define function for risk map
risk_map <- function(data = acd,
                     map = zam_sp){
  
  # Jitter the data
  data <- data %>%
    mutate(lng = jitter(lng, factor = 50),
           lat = jitter(lat, factor = 50))
  
  # Group by location and get overall
  grouped <- data %>%
    group_by(lng, lat) %>%
    summarise(cases = sum(had_malaria == 1),
              population = n()) %>%
    ungroup %>%
    mutate(pk = cases / population * 100) %>%
    filter(!is.na(lng), 
           !is.na(lat))
  
  # Perform kriging
  # Krieging
  sp_df <- grouped
  coordinates(sp_df) <- ~lng + lat
  proj4string(sp_df) <- proj4string(map)
  sp_df <- sp_df[!is.na(sp_df$pk),]
  sp_points <- SpatialPoints(sp_df)
  
  # Create a fine grid
  pixels_per_side = 150
  bottom.left = bbox(map)[,1]  #apply(sp_points@coords,2,min)
  top.right = bbox(map)[,2] #apply(sp_points@coords,2,max)
  margin = abs((top.right-bottom.left))/10
  bottom.left = bottom.left-margin
  top.right = top.right+margin
  pixel.size = abs(top.right-bottom.left)/pixels_per_side
  g = GridTopology(cellcentre.offset=bottom.left,
                   cellsize=pixel.size,
                   cells.dim=c(pixels_per_side,pixels_per_side))
  
  grid_points = SpatialPoints(g)
  proj4string(grid_points) <- proj4string(map)
  in_points = !is.na(over(grid_points,polygons(map)))
  fit_points = SpatialPoints(as.data.frame(grid_points)[in_points,])
  proj4string(fit_points) <- proj4string(map)
  
  # make projected before krieging
  new_pro <- CRS("+init=epsg:3036")
  proj4string(fit_points) <-
    proj4string(map) <- 
    proj4string(sp_df) <- new_pro
  
  # Do kriging
  krig = autoKrige(pk~1, sp_df, new_data=fit_points)
  interp_data = as.data.frame(krig$krige_output)
  colnames(interp_data) = c("longitude","latitude","pred","var","stdev")
  
  # Set up map plot
  map_base_aesthetics = aes(x=longitude, y=latitude, group=group)
  map_base = geom_polygon(data=map, map_base_aesthetics)
  borders = geom_polygon(data=map, map_base_aesthetics, color="black", fill=NA)
  
  # Fortify map
  map_fortified <- broom::tidy(map)
  
  nbin=20
  
  g <-
    ggplot(data=interp_data, aes(x=longitude, y=latitude)) + 
    geom_polygon(data = map_fortified, aes(x = long,
             y = lat,
             # z = p_positive,
             group = group),
             alpha = 0.6) +
    # coord_map() +
    geom_tile(aes(fill=pred),color=NA) +
    # stat_contour(aes(z=pred), bins=nbin, color="#999999") +
    scale_fill_gradient2(name = '%',
                         # midpoint=mean(interp_data$pred),
                         # limits = c(0, 100),
                         # midpoint = 300,
                         low="white",
                         mid="yellow",
                         high="red") +
    # borders +
    theme_cism() +
    labs(title = '',
         subtitle = 'Interpolated average weekly positivity rate, Krieging method',
         x = 'Longitude',
         y = 'Latitude')
  return(g)
}


# Create a week column in acd
date_start <- as.Date(min(acd$acd_visit_date))
date_end <- as.Date(max(acd$acd_visit_date))

date_helper <-
  tibble::data_frame(date = seq(date_start,
                                date_end,
                                by = 1)) %>%
  mutate(dow = weekdays(date)) %>%
  filter(date >= '2016-10-01') %>%
  mutate(week = as.character(NA))
for (i in 1:nrow(date_helper)){
  this_week <- date_helper$date[i]
  this_dow <- date_helper$dow[i]
  while(this_dow != 'Monday'){
    this_week <- this_week - 1
    this_dow <- weekdays(this_week)
  }
  date_helper$week[i] <- as.character(this_week)
}
date_helper$week <- as.Date(date_helper$week)

acd <- 
  acd %>%
  left_join(date_helper,
            by = c('acd_visit_date' = 'date'))
  
weeks <- sort(unique(acd$week))


for (i in 1:length(weeks)){
  message(i)
  data <- acd %>%
    filter(week == weeks[i])
  try({
      r <- risk_map(data = data,
           map = zam_sp) +
    labs(title = weeks[i])
  assign(paste0('g', i),
         r)
  })

}
```


### Overall ACD positivity rate

```{r, results = 'hide'}
x <- risk_map(data = acd,
           map = zam_sp) +
  labs(title = 'ACD risk map')
```

```{r}
x
```

### Week-specific ACD positivity rates

```{r, fig.width=8}
Rmisc::multiplot(g1,
                 g2,
                 g3,
                 g4,
                 cols = 2)
```

```{r, eval = FALSE}
# ANIMATION
for (i in 1:length(weeks)){
  x <- get(paste0('g', i))
  print(x)
  Sys.sleep(0.5)

  ggsave(paste0('animation/', i, '.png'))
}

```


## Prevalence and incidence calculations

We can calculate incidence and prevalence for ACD data as well. For this, our denominator consists of only those children recruited for the study.

### Overall malaria positivity

```{r}
x <- acd %>%
  group_by(malaria = ifelse(had_malaria == 1, 'Positive', 'Negative')) %>%
  tally %>%
  ungroup %>%
  filter(!is.na(malaria)) %>%
  mutate(p = n / sum(n) * 100)

ggplot(data = x,
       aes(x = malaria,
           y = n)) +
  geom_bar(stat = 'identity',
           color = 'black',
           fill = 'darkorange',
             alpha = 0.6) +
  theme_cism() +
  labs(title = 'Malaria status in ACD',
       subtitle = paste0(nrow(acd), ' ACD participants'),
       x = 'Test result',
       y = 'Children') +
  geom_label(aes(label = paste0(round(p, digits = 2), '%')))
```

### Weekly incidence

```{r}
weekly_incidence <- 
  acd %>%
  group_by(week) %>%
  summarise(positives = length(which(had_malaria == 1)),
            n = n()) %>%
  ungroup %>%
  mutate(p = positives / n * 1000) %>%
  filter(!is.na(week)) %>%
  mutate(negatives = n - positives) %>%
  filter(n > 5)

ggplot(data = weekly_incidence,
       aes(x = week,
           y = p)) +
  geom_area(fill = 'darkorange',
            alpha = 0.6,
            color = 'black') +
  labs(title = 'Weekly incidence of malaria per ACD data',
       subtitle = 'Per 1,000, denominator is only those in ACD',
       x = 'Week',
       y = 'Incidence per 1k') +
  theme_cism()
```

### Incidence by spray status

```{r}
x <- acd %>%
  group_by(week,
           spray = ifelse(spray == 1, 'Spray', 'No spray')) %>%
  summarise(positives = length(which(had_malaria == 1)),
            n = n()) %>%
  ungroup %>%
  mutate(p = positives / n * 1000) %>%
  filter(!is.na(week)) %>%
  mutate(negatives = n - positives) %>%
  filter(n > 5) %>%
  rename(People = n)

cols <- colorRampPalette(brewer.pal(9, 'Spectral'))(length(unique(x$spray)))
ggplot(data = x,
       aes(x = week,
           y = p,
           group = spray,
           color = spray)) +
  geom_line() +
  geom_point(aes(size = People),
             alpha = 0.5) +
  labs(title = 'Weekly incidence of malaria per ACD data',
       subtitle = 'Per 1,000, denominator is only those in ACD',
       x = 'Week',
       y = 'Incidence per 1k') +
  theme_cism() +
  scale_color_manual(name = 'Status',
                     values = cols)
```


## Breakdown of spray status per data collected

```{r}
cism_plot(x = factor(ifelse(is.na(acd$spray), 'NA', acd$spray))) +
  labs(x = 'Spray',
       title = 'Spray status per data collected')
```

## Breakdown of test restuls

```{r}
# 4 = not done
cism_plot(x = factor(ifelse(is.na(acd$test_result), 'NA', acd$test_result))) +
  labs(x = 'Test result',
       title = 'Test restuls')
```

## Not yet finished analyses

If not treated, why.

If write-in, what were the write-ins

## Malaria prevalence

Which variables to use for this?

## Net ownership vs. malaria prevalence

```{r, echo = TRUE}
# NEED TO RENAME THESE VARIABLES
# Undernet_Sleep - How many times the child sleeps under mosquito net during rainy season!
# Undernet_Sleeps - How many times the child sleeps under mosquito net during dry season!

table(acd$undernet_sleep)
table(acd$undernet_sleeps)
table(acd$undernet_sleep,
      acd$undernet_sleeps)

```

# Ad-hoc requests

## Age of ACD participants


```{r}
clean_perm_id <- function(perm_id){
  x <- strsplit(perm_id, '-')
  y <- lapply(x, 
         function(x){
           as.numeric(as.character(x))
         })
  z <- lapply(y, function(a){
    paste0(a, collapse = '-')
  })
  zz <- unlist(z)
  return(zz)
}
# Get age from census
left <- acd %>%
  mutate(id = clean_perm_id(perm_id = perm_id))  %>%
  dplyr::select(-dob)
right <- master_table %>%
              mutate(id = clean_perm_id(permid)) %>%
  mutate(in_census = TRUE)
x <- left_join(left, right, by = 'id') %>%
  mutate(ifelse(is.na(in_census), FALSE, in_census))
# write_csv(x %>% filter(is.na(dob)), '~/Desktop/empty_acd.csv')

ggplot(data = x,
       aes(x = dob)) +
  geom_histogram(alpha = 0.6,
                 fill = 'darkgreen') +
  theme_cism() +
  labs(x = 'Date of birth',
       y = 'Count',
       title = 'Distribution of dates of birth',
       subtitle = 'ACD participants')

```

As an alternative to the above, we can explore age (in months).

```{r}
x$months <- as.numeric(as.Date('2017-01-12') - x$dob) / (365.25 / 12)

ggplot(data = x,
       aes(x = months)) +
  geom_histogram(alpha = 0.6,
                 fill = 'darkgreen') +
  theme_cism() +
  labs(x = 'Months of age',
       y = 'Count',
       title = 'Distribution of ages',
       subtitle = 'ACD participants') +
geom_vline(xintercept = seq(0, 72, by= 12),
           lty = 2,
           alpha = 0.5)
```


## Details on person 116-7014-0015-02

```{r}
pid <- '116-7014-0015-02'
# clean_perm_id(pid) %in% clean_perm_id(master_table$permid)
this_person <- master_table %>%
  filter(clean_perm_id(pid) == clean_perm_id(permid )) %>%
  mutate(status = ifelse(status, 'Spray', 'No spray'))

DT::datatable(this_person)
```

```{r}
plot(zam_sp)
points(this_person$lng,
       this_person$lat)
```

```{r}
library(leaflet)
master_table_sp <- master_table
coordinates(master_table_sp) <- ~lng+lat
proj4string(master_table_sp) <- proj4string(zam_sp)
master_table_sp@data$xx <- master_table_sp@data$permid == this_person$permid
# this_person_sp <- this_person
# coordinates(this_person_sp) <- ~lng+lat
# mapview::mapview(master_table_sp,
#                  color = ifelse(master_table_sp@data$xx, 'red', 'blue'))

colors <- ifelse(master_table_sp@data$xx, 'red', 'blue')
ll <- 
  leaflet() %>%
  addProviderTiles("OpenStreetMap.Mapnik") %>%
  addCircleMarkers(lng = master_table$lng,
    lat = master_table$lat,
    color = colors,
    fillColor = colors,
    radius = 2.5,
    opacity = 0,
    fillOpacity = 0.5,
    popup = paste0('Household: ', master_table$house_number, ' Village number: ',
    master_table$village_number)) %>%
    addLegend("bottomright", 
              colors = c('red', 'blue'),
              labels = c(paste0('This person'), 
                         'Others'),
    title = '',
    opacity = 1 ) %>%
  addCircleMarkers(lng = this_person$lng,
    lat = this_person$lat,
    color = 'red',
    fillColor = 'red',
    radius = 2.5,
    opacity = 0,
    fillOpacity = 0.5,
    popup = paste0('Household: ', this_person$house_number, ' Village number: ',
    this_person$village_number))
ll
```

# Map for each village

```{r}
kids <- children %>%
  left_join(census %>%
              dplyr::select(uri,
                            lng,
                            lat,
                            locality_Final) %>%
              rename(locality = locality_Final),
            by = c('parent_auri'='uri'))
kids$color <- ifelse(kids$status, 'red', 'blue')


villages <- sort(unique(kids$village_number))
localities <- sort(unique(kids$locality))
cols <- colorRampPalette(brewer.pal(9, 'Spectral'))(length(villages))
cols <- sample(cols, length(cols))

locality_cols <- colorRampPalette(brewer.pal(9, 'Spectral'))(length(localities))
locality_cols <- sample(locality_cols, length(locality_cols))

kids$village_color <- cols[as.numeric(factor(kids$village_number))]
kids$locality_color <- locality_cols[as.numeric(factor(kids$locality))]

pdf('~/Desktop/villages_by_gps.pdf',
    width = 11,
    height = 8.5)
for (i in 1:length(villages)){
  par(mfrow = c(1,2))
  this_village <- villages[i]
  these_kids <- kids %>%
    filter(village_number == this_village)
  this_locality <- paste0(sort(unique(these_kids$locality)), collapse = ', ')
  plot(zam_sp,
       main = paste0('Village ', this_village, ', locality: ',
                     this_locality
                     ))
  points(these_kids$lng,
         these_kids$lat,
         pch = 3,
         col = adjustcolor(these_kids$color, alpha.f = 0.6),
         cex = 0.4)
  plot(these_kids$lng,
       these_kids$lat,
        pch = 3,
         col = adjustcolor(these_kids$color, alpha.f = 0.6),
         cex = 0.4,
       main = paste0('Village ', this_village,
                           ' zoom-in'),
       xlab = 'Longitude',
       ylab = 'Latitude')
  legend('topright',
         col = c('red', 'blue'),
         pch = 3,
         legend = c('Spray', 'No spray'),
         title = 'Assigned status',
         cex = 0.4)
  # Sys.sleep(1)
}
dev.off()
par(mfrow = c(1,1))


pdf('~/Desktop/localities_by_gps.pdf',
    width = 11,
    height = 8.5)
for (i in 1:length(localities)){
    par(mfrow = c(1,2))
  this_locality <- localities[i]
  these_kids <- kids %>%
    filter(locality == this_locality)
  these_villages <- paste0(sort(unique(these_kids$village_number)),
                           collapse = ',')
  plot(zam_sp,
       main = paste0('Locality ', this_locality))
  points(these_kids$lng,
         these_kids$lat,
         pch = 3,
         col = adjustcolor(these_kids$village_color, alpha.f = 0.6),
         cex = 0.4)
  plot(these_kids$lng,
       these_kids$lat,
        pch = 3,
         col = adjustcolor(these_kids$village_color, alpha.f = 0.6),
         cex = 0.4,
       main = paste0('Village ', this_village,
                           ' zoom-in'),
       xlab = 'Longitude',
       ylab = 'Latitude')

}
dev.off()
par(mfrow = c(1,1))

l <- leaflet() %>%
  # addTiles() %>%
  addProviderTiles('Esri.WorldImagery') %>%
  addCircles(lng = kids$lng,
             lat = kids$lat,
             col = kids$village_color,
             popup = paste0('Village: ',
                            kids$village_number,
                            ' | permid: ',
                            kids$permid))

l2 <- leaflet() %>%
  addTiles() %>%
  # addProviderTiles('Esri.WorldImagery') %>%
  addCircles(lng = kids$lng,
             lat = kids$lat,
             col = kids$locality_color,
             popup = paste0('Locality: ',
                            kids$locality,
                            ' | Village: ',
                            kids$village_number,
                            ' | permid: ',
                            kids$permid))

# Create a village number / locality table
village_locality <- 
  kids %>%
  arrange(locality, village_number) %>%
  filter(!duplicated(village_number)) %>%
  dplyr::select(locality, village_number)
write_csv(village_locality,
          'village_locality_matchup.csv')
```